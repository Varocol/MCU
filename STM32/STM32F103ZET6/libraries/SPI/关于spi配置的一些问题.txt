NSS配置
1.nss软件主模式
   直接指定一个GPIO控制从设备
   内部是由ssi控制,可以设置为0或1
   nss引脚配置为推挽输出,需要选择从设备时拉低电平,
   不需要就高电平,在从设备的nss引脚上最好外接一个上拉电阻。
2.nss软件从模式
   配置为从模式时mstr为必须为0,并且ssm为1,ssi为0,
   这样nss引脚被拉低,这个时候nss引脚不需要,这种模式一般很少使用。
3.nss硬件主模式
   该模式有两种情况,首先ssm应当被设置成0,并且这里的引脚应当配置
   为复用推挽输出(只要是硬件模式下必须配置硬件GPIO,并且要使nss引脚连接到高电平,否则spi不工作),
   若ssoe=0时,此时为输入模式,nss引脚应当连接至高电平,
   这里可以理解为虽然引脚配置为推挽输出,但是GPIO的输入部分仍然能够采集
   引脚电平,若采集到低电平则会进入MODF,并自动转入从模式,所以该模式下能够自动切换
   也称能够工作在多主模式下,需要注意的是,想要控制从设备,还需使用另外一个GPIO控制。
   若ssoe=1时,此时为输出模式,nss引脚被自动拉低,这时不需要nss接高电平,
   该引脚的低电平会持续到SPI被关闭之前,所以该模式下不能工作在多主模式下。
4.nss硬件从模式
   该模式ssm=0,ssoe关闭,nss引脚可以配置为浮空/上拉/下拉输入,
   这个时候nss引脚作为输入端,在工作情况下,nss引脚应当为低电平。
疑惑：
一、nss软件主模式下内部ssi需要被配置为1吗,根据中文
参考手册中"只当NSS引脚被连接到高电平,这些位才能被置位",
以及"在NSS引脚软件模式管理下,SSI被置为0,会产生主模式
失效错误",ssi应当被配置为1。
答：通过翻阅资料显示,stm32固件库中有个配置是SPI_MODE,
对应的SPI_Mode_Master的值为0x0104,该值能够同时配置ssi
和mstr位,所以在初始化spi时不需要再重新配置ssi位了。
二、nss硬件主模式下当ssoe设置为1时,外部nss引脚被拉低,但是
内部的nss需要被读取到高电平,那不会冲突吗？
当ssoe=1时,此时nss被配置为输出模式,所以不需要外接高电平,
文档中针对的应该是输入模式的情况。

总结：
在主模式下,无论是软件还是硬件,内部nss必须给到高电平,若模式为软件,则ssi应当设置为1,
同理,硬件模式下,内部nss连接到外部指定的nss引脚,所以外部可以选择上拉电阻来给到高电平。


20220720
1.发现SPI SSOE位为0时,电平始终为低电平,这个不能使用GPIO修改。并且在SSOE关闭后
spi模块不能在控制引脚输出低电平。
解决方案:
根据网上相关资料,需要先将SPI模块先关闭,释放该引脚,然后再使用GPIO控制这个引脚在SPI不用时
拉高nss,需要拉低时再使能SPI就行。
2.在测试模式4的时候,由于软件从模式需要另外GPIO当作输入引脚,所以采用了EXTI中断来读取并
修改spi内部nss引脚值的方案,但是在实际测试中发现读取gpio出了一点意外,gpio在没有被初始化
的时候读出来的值一直都是复位值,因为代码里使用了延时并且通过万用表测试过引脚高低电平的变化。
解决方案:
初始化gpio。

20220725
1.发现在使用DMA接收数据时,不使用CRC校验时,传输没有问题,但是一旦使用CRC校验,接收到的数据就出错,
原因是由于启用CRC校验后,发送端需要发送校验码,也就导致发送的数据长度可能会超出DMA预期接收长度。
解决方案:
可以将接收长度加长,也可以复位DMA使得用于接收数据的指针复位。

20220805
针对CRC问题终于总结出方法首先可能会想到在需要发送CRC校验码的时候关闭DMA传输,但是实际测验出来这会导致
CRC校验码传输出错,校验失败,所以采用第二种方法,按照正常的长度(不包含校验码)配置,这虽然会使得最后的CRC
校验码将接收数据的一个被篡改为CRC校验码,但是实际上校验成功,然后将最开头那个数据记录即可,但是实际上使
用DMA传输时无法截获数据,所以这个方法只能说成功一半,第三种方法是,在第二种方法的基础之上改变一下需要传
输的数据,将数据最开头的位置放置一个无用的数据,然后提取数据时只需从下标为1的地方提取。第四种方法,就是
将DMA传输的长度加1即加上CRC校验码的长度(不一定是1,如果传的是16位的数据那就是2),然后发送端的CRC校验码
就会被当作数据参与CRC校验计算,结果得0,所以可以不用看CRCERR标志位,直接检查计算的CRC是否为0即可。
最后一种方法是将校验码手动发送过来,然后手动比较即可,但有可能会出错,因为发送端的CRC可能还在计算中。
总结起来就是CRC校验和DMA会起冲突,如果不使用DMA接收,则spi能够自动辨别校验码,如果使用DMA,则不将
CRC校验码的长度计算在内则最开头的数据会被篡改,如果计算在内,则无法进行CRC校验,会导致CRC校验失败,
所以应该是一个BUG,当初设计CRC的时候没有想到校验码不应该当作数据,否则会引起DMA递增指针的变化。
总的来说推荐第三种和第四种方法,都能达到校验的目的。

20220805
经过了一下午的测试发现上面的结论胡扯，可能是由于硬件缘故，导致调出来的结果有些问题，其实确实由于每次传输
都涉及CRC校验码的问题，导致DMA递增指针位置从头开始了，但是可以发现的是每次初始化第一次输出的结果和校验结果
都没有问题，所以只需要将DMA复位即可，但是DMA初始化一次不够，需要连续初始化两次，原因未知。初始化两次后校验
和数据都没有问题了。