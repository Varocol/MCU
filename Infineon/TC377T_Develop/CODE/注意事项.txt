该文本用于存储编程过程中发现的bug和需要注意的点

2021/12/25
oyjj
1.
发现cpu0可以直接申明带有参数的类，不需要借助于函数初始化
而cpu1和cpu2需要在初始化函数里给定参数才能初始化，
简单来说就是cpu1 cpu2不支持已有参数的类的全局变量。
详见改动细节
2.
只有cpu0才能使用rtthread相关的函数，其他核使用时会导致所有核瘫痪
3.
cpu1和cpu2抢占一个引脚时cpu2的优先级比cpu1要高，
可以在cpu1中写一个呼吸灯再在cpu2中写一个亮灯，两盏灯相同的引脚，结果发现无论如何都是cpu2优先

2022/1/3
oyjj
1.
cpu0,cpu1,cpu2统一采用在函数外申明全局类，在初始化函数内用Set_Param接口配置类的参数
2.
宏定义使用时参数如果为表达式一定要加括号！！！
3.
MT9V03x_Get_Conf();
MT9V03x_Show_Info();
这两个函数只允许在核0使用。
4.
存储图像时用了4个超大的图像存储空间，总共88kb(mt9v03x_image,buffer_image,temp_image,result_image)，
所以在使用时同时使用4个缓冲区可能导致程序崩溃

2022/2/14
oyjj
1.
使用delete的时候要一个一个使用，例如：
delete a;
delete b;
不能delete a,b;
2.
*a++和(*a)++是不一样的
3.
表达式运算的时候强制类型转换一定要在靠前的位置加一个高级类型，例如：
int a = 22222,b = 22222;
long long c = 12;
c = (long long)a * b / c;
如果是c = (long long)(a * b) / c;的话这时候a*b先会被运算，且参与运算的类型为a和b较高级的类型(int)
这样以来前面的(long long)就没有用了，所以强制转换类型一定要紧挨着变量或表达式。
4.
c *= (a * b);和 c = c * (a * b);其实是有点区别的，如果使用前式，那么运算顺序是先计算(a*b)然后再将结果
与c相乘，这样以来如果(a*b)超过范围限制，那么结果会出错，如果使用后式，那么运算顺序为先将整个式子的类型判定为c
的类型(long long),这样以来a和b的运算类型也会被判定为longlong,
所以结果不会出错(在a*b超过int类型范围而不超过longlong的前提下)

2022/2/16
oyjj
1.
优化算法的方式就是尽量少用除法，尽量用乘法

2022/2/19
oyjj
1.
systick_delay()函数有自动切换stm模块的功能。
所以延时尽量使用该延时
2.
以后底层模块的延时统一使用platform_delay()
输出部分可以使用platform_output();
3.
更改Button类的初始化方式
保留了原有的Button的初始化方式，但是全部得Init(),否则无法使用
4.
添加了宏定义重定向printf
5.
使用类的时候内部变量最好别初始化，cpu1/2的顺序是先执行函数在初始化变量不知道为啥